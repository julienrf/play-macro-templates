@()(implicit ctx: PageContext)

@page {

    <p>In Play! framework, HTML templates are Scala functions generated by the build system. To render a given template, you have to statically refer to its value:</p>

    <pre><code>views.html.pages.foo()</code></pre>
    <pre><code>views.html.pages.bar()</code></pre>

    <p>You can not (easily) select which page to render according to a dynamic value. For instance, how can you implement the following function?</p>

    <pre><code>def renderPage(name: String): Html = ???</code></pre>

    <p>This function should render the <code>views.html.pages.foo</code> template if it is passed the <code>"foo"</code> value, and the <code>views.html.pages.bar</code> template if it is passed the <code>"bar"</code> value (and so on with other pages).</p>

    <p>The good thing is that, because Play! templates are just Scala values, we can put them in a map:</p>

    <pre><code>val pages = Map(
  "foo" -> views.html.pages.foo,
  "bar -> views.html.pages.bar
)

def renderPage(name: String): Html =
  pages.get(name) map (_.render()) getOrElse sys.error("Oops! The page does not exist")</code></pre>

    <p>Note that in order to get this code working, the templates <code>foo</code> and <code>bar</code> must have the same type signature.</p>

    <p>The above solution requires to manually write the mapping between page names and templates, which is a tedious task. Thatâ€™s why I propose to use a macro to compute the map at compile time, by looking at the templates available in the <code>views.html.pages</code> package (for example).</p>

    <p>Now the map definition just calls the macro:</p>

    <pre><code>val pages = Templates.byName("views.html.pages")</code></pre>

    <p>The <a href="https://github.com/julienrf/play-macro-templates/blob/master/macro-templates/src/main/scala/macrotemplates/Templates.scala"><code>Templates.byName</code></a> macro takes a package name as parameter, looks at the Play! templates that are defined within this package and returns them as a map indexed by their name.</p>

    <p>Then, in my Play! application, I can define the following route:</p>

    <pre><code>GET   /:name       controllers.Application.page(name)</code></pre>

    <p>And dynamically call the template corresponding to the requested page:</p>

    <pre><code>object Application extends Controller {
  def page(name: String) = Action {
    pages.get(name) match {
      case Some(page) => Ok(page.render())
      case None => NotFound
    }
  }
}</code></pre>

  <p>Now, to add a new page to my application, I just have to create a new template under the <code>app/views/pages/</code> directory.</p>

}
